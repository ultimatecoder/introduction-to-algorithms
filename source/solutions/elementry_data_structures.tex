\chapter{Elementary Data Structures}
  \section{Stacks and Queues}
    \subsection {}

    Using Figure 10.1 as a model, illustrate the result of each operation in
    the sequence \textit{PUSH(S, 4), PUSH(S, 1), PUSH(S, 3), POP(S), PUSH(S,
    8)}, and \textit{POP(S)} on an initially empty stack \textit{S} stored in
    array S[1..6].

      \subsubsection {Answer}

      Below are various state of a Stack after performing mentioned operations.

      \textit{PUSH(S, 4)}

      \begin{verbatim}
        S = [4, null, null, null, null, null]
        s.top = 0
      \end{verbatim}

      \textit{PUSH(S, 1)}

      \begin{verbatim}
        S = [4, 1, null, null, null, null]
        S.top = 1
      \end{verbatim}

      \textit{PUSH(S, 3)}

      \begin{verbatim}
        S = [4, 1, 3, null, null, null]
        S.top = 2
      \end{verbatim}

      \textit{POP(S)}

      \begin{verbatim}
        S = [4, 1, null, null, null, null]
        S.top = 1
      \end{verbatim}

      \textit{PUSH(S, 8)}

      \begin{verbatim}
        S = [4, 1, 8, null, null, null]
        S.top = 2
      \end{verbatim}

      \textit{POP(S)}

      \begin{verbatim}
        S = [4, 1, null, null, null, null]
        S.top = 1
      \end{verbatim}

      \subsection{}

      Explain how to implement two stacks in one Array A[1..n] in such a way
      that neither stack overflows unless the total number of elements in both
      stacks together is n. The \textit{PUSH} and \textit{POP} operations
      should run in O(1) time.

        \subsubsection {Answer}

        We can implement two stacks in one Array by putting two reference
        pointers on an Array.

        Let us call S1 a stack which stores elements from a beginning to an end
        in an increment order in an Array. S1 has a pointer called ``top``
        which is being incremented at the time of adding an element. ``top`` is
        decremented when element is removed from stack.

        Let us call S2 a stack which stores elements from end to beginning in a
        decrement order on same Array. S2 has a pointer called ``end`` which is
        being decremented at the time of adding element. ``end`` is incremented
        when element is removed from an stack.

        An overflow of stack can be identified by three conditions. One is when
        pointer of S1 and S2 reaches at a same position. Second is when pointer
        of S1 reaches an end of an array. Third is when pointer of S2 reaches
        at a beginning of an array.

        We can identify an underflow of a stack by measuring that pointer of S1
        is not less than zero (0) and pointer of S2 is not greater than size of
        an array.

        Below is a pseudocode for \textit{PUSH} and \textit{POP} operations of
        both stacks. Operations for stack S2 which stores elements via pointer
        placed at an end of an Array.

        \begin{verbatim}
          STACK-EMPTY(S)
            if S.end == S.length
              return TRUE
            else
              return FALSE
        \end{verbatim}

        \begin{verbatim}
          PUSH(S, item)
            S.end = S.end - 1
            if S.end == S.top Or S.end < 0
              error ``Overflow``
            else
              S[s.end] = item
        \end{verbatim}

        \begin{verbatim}
          POP(S, item)
            if STACK-EMPTY(S)
              return ``Underflow``
            else
              S.end = S.end + 1
              return S[S.end - 1]
        \end{verbatim}

        Operations of stack S1 which stores elements from front will be same as
        defined in normal stack except \textit{PUSH} operation. Below is a code
        of \textit{PUSH} operation.

        \begin{verbatim}
          PUSH(S, item)
            S.top += 1
            if S.top == S.end or S.top == S.length
              return ``Overflow``
            else
              S[S.top] = item
        \end{verbatim}

      \subsection{}

      Using Figure 10.2 as a model, illustrate the result of each operation in
      the sequence \textit{ENQUEUE(Q, 4)}, \textit{ENQUEUE(Q, 1)},
      \textit{ENQUEUE(Q, 3)}, \textit{DEQUEUE(Q)}, \textit{ENQUEUE(Q, 8)}, and
      \textit{DEQUEUE(Q)} on an initially empty queue Q stored in array
      Q[1..6].

        \subsubsection{Answer}

          Below are state of queue after performing sequene of \textit{ENQUEUE}
          and \textit{DEQUEUE}.

          \textit{ENQUEUE(Q, 4)}
          \begin{verbatim}
            Q = [4, null, null, null, null, null]
            Q.head = 1
            Q.tail = 1
          \end{verbatim}

          \textit{ENQUEUE(Q, 1)}
          \begin{verbatim}
            Q = [4, 1, null, null, null, null]
            Q.head = 1
            Q.tail = 2
          \end{verbatim}

          \textit{ENQUEUE(Q, 3)}
          \begin{verbatim}
            Q = [4, 1, 3, null, null, null]
            Q.head = 1
            Q.tail = 3
          \end{verbatim}

          \textit{DEQUEUE(Q)}
          \begin{verbatim}
            Q = [null, 1, 3, null, null, null]
            Q.head = 2
            Q.tail = 3
          \end{verbatim}

          \textit{ENQUEUE(Q, 8)}
          \begin{verbatim}
            Q = [null, 1, 3, 8, null, null]
            Q.head = 1
            Q.tail = 4
          \end{verbatim}

          \textit{DEQUEUE(Q)}
          \begin{verbatim}
            Q = [null, null, 3, 8, null, null]
            Q.head = 2
            Q.tail = 3
          \end{verbatim}

          In above code, I am depicting an empty elements position as a
          \textit{null}.

      \subsection{}

      Rewrite \textit{ENQUEUE} and \textit{DEQUEUE} to detect underflow and
      overflow of a queue.

        \subsubsection {Answer}

        \begin{verbatim}
          ENQUEUE(Q, item)
            if Q.tail == Q.length
              Q.tail = 1
            else
              Q.tail = Q.tail + 1
            if Q.tail == Q.head:
              error ``Overflow``
            else
              Q[Q.tail] = item

          DEQUEUE(Q)
            if Q.head == Q.tail + 1
              return ``Underflow``
            else
              item = Q[Q.head]
            if Q.head == Q.length
              Q.head = 1
            else
              Q.head = Q.head + 1
            return item
        \end{verbatim}

      \subsection{}

      Whereas a stack allows insertion and deletion of elements at only one
      end, and a queue allows insertion and one end and deletion at the other
      end, a \textit{deque} (double-ended queue) allows insertion and deletion
      at both ends. Write four O(1) time procedures to insert elements into and
      delete elements from both ends of a deque implemented by an array.

        \subsubsection{Answer}
          Below are four operations to be performed on double ended queue.

          TODO: Treat this queue as a circular queue. Implement each method to
          detect underflow and overflow conditions.

          \begin{verbatim}

            FRONT-ENQUEUE(Q, intem)
              Q.head = Q.head - 1
              if Q.head == 0
                Q.head = Q.length
              Q[Q.head] = item

            REAR-ENQUEUE(Q, item)
              if Q.tail == Q.length
                Q.tail = 1
              else
                Q.tail = Q.tail + 1
              Q[Q.tail] = item

            FRONT-DEQUEUE(Q, item)
              item = Q[Q.head]
              if Q.head == Q.length
                Q.head = 1
              else
                Q.head = Q.head + 1
              return item

            REAR-DEQUEUE(Q, item)
              item = Q[Q.tail]
              Q.tail = Q.tail - 1
              if Q.tail == 0
                Q.tail = Q.length
              return item
          \end{verbatim}

      \subsection{}

        Show how to implement a queue using two stacks. Analyze the running
        time of the queue operations.

        \subsubsection{Answer}

        Below is an implementation of queue using two stacks.

        \begin{verbatim}
          ENQUEUE(Q, item)
            PUSH(S1, item)

          DEQUEUE(Q)
            while S1 is not empty
              other_item = POP(S1)
              PUSH(S2, other_item)
            item = POP(S2)
            while S2 is not empty
              other_item = POP(S2)
              PUSH(S1, other_item)
            return item
        \end{verbatim}

        In above approach, an \textit{ENQUEUE} operation is achieved in O(1)
        run-time, but a \textit{DEQUEUE} operation will take O(N).

      \subsection{}

        Show how to implement a stack using two queues. Analyze the running
        time of the stack operations.

        \subsubsection{Answer}

        Below is an implementation of stack using two queues.

        \begin{verbatim}

          PUSH(S, item)
            ENQUEUE(Q1, item)

          POP(S)
            while Q1.length != 1
              other_item = DEQUEUE(Q1)
              ENQUEUE(Q2, other_item)
            item = DEQUEUE(Q1)
            while Q2 is not empty
              other_item = DEQUEUE(Q2)
              ENQUEUE(Q1, other_item)
            return item
        \end{verbatim}

        A run-time of \textit{PUSH} operation can be achieved in O(1).
        \textit{POP} operation will take O(N) to remove an element from top.

  \section{Linked Lists}

    \subsection{}

    Can you implement the dynamic-set operation \textit{INSERT} on a singly
    linked list in O(1) time? How about \textit{DELETE}?

    \subsubsection{Answer}

    Yes, we can achieve dynamic-set operation \textit{INSERT} on a singly
    linked list in O(1) by inserting new element at a position of head. Below
    is a pseudocode for \textit{INSERT} operation which takes O(1) time to
    insert a new element into a dynamic set.

    \begin{verbatim}
      INSERT(L, element)
        if L.head is not null
          element.next = L.head
          L.head = element
        else
          L.head = element
          L.head.next = null
    \end{verbatim}

    There is any possibility to achieve dynamic-set operation \textit{DELETE}
    in O(1) run-time.

    \subsection{}

    Implement a stack using a singly linked list L. The operations
    \textit{PUSH} and \textit{POP} should still take O(1) time.

    \subsubsection{Answer}

    To implement a stack data structure on singly linked list, we have to
    insert and delete elements from a head of a list. We can achieve insert and
    delete operations on stack data structure in O(1).

    Below is a pseudocode for \textit{PUSH} and \textit{POP} operations.

    \begin{verbatim}
      PUSH(S, item)
        if S.head is not null
          item.next = S.head
        S.head = item

      POP(S)
        item = S.head
        if item is null
          error ``Underflow``
        S.head = S.head.next
        return item
    \end{verbatim}

    \subsection{}

    Implement a queue by singly linked list L. The operations \textit{ENQUEUE}
    and \textit{DEQUEUE} should still take O(1) time.

    \subsubsection{Answer}

    To implement a queue data structure using singly linked list, we have to
    maintain two references of linked list node. One pointer reference at a
    head of a queue and another pointer reference at a tail of a queue. New
    element is enqued at a head and old element is removed from a tail of a
    queue.

    Below is a pseudocode for \textit{ENQUEUE} and \textit{DEQUEUE} operations.

    \begin{verbatim}
      ENQUEUE(Q, item)
        if Q.tail is not null
         Q.tail.next = item
        Q.tail = item
        if Q.head is null
          Q.head = item

      DEQUEUE(Q)
        if Q.head is null
          error ``Underflow``
        item = Q.head
        if Q.tail == Q.head
          Q.tail = null
        Q.head = Q.head.next
    \end{verbatim}

    Run-time of both operations is O(1).

    \subsection{}

    As written, each loop iteration in the \textit{LIST-SEARCH'} procedure
    requires two tests: one for $x != L.nil$ and one for $x.key != k$. Show how
    to eliminate the test for $x != L.nil$ in each iteration.

    \subsubsection{Answer}

    For eliminating a test for $x != L.nil$ in each iteration we simply have to
    add expected key at $L.nil$ so the while loop at least terminates by
    finding one value of key in worst case scenario. Below is a code for
    updated \textit{LIST-SEARCH'} operation.

    \begin{verbatim}
      LIST-SEARCH(L, key)
        element = L.nil.next
        L.nil.key = key
        while element.key != key
          element = element.next
        L.nil.key = null
        return element
    \end{verbatim}


    \subsection{}

    Implement the dictionary operations \textit{INSERT}, \textit{DELETE}, and
    \textit{SEARCH} using singly linked, circular lists. What are the running
    times of your procedures?

    \subsubsection{Answer}
    \begin{verbatim}
    INSERT(L, element)
      element.next = L.head
      L.head = element
      if L.tail != null
        L.tail.next = L.head
      else
        L.tail = L.head

    DELETE(L, element)
      if element == L.head
        L.head = element.next
        L.tail.next = L.head
      else element == L.tail
        previous_element = L.head
        while previous_element.next != L.tail
          L.tail = previous_element
          L.tail.next = L.head
      else
        previous_element = L.head
        while previous_element.next != element and previous_element != L.tail
          previous_element = previous_element.next
        previous_element.next = element.next

    SEARCH(L, key)
      element = L.head
      while element.key != key and element != L.tail
        element = element.next
      if element.key == key
        return element
      else
        return null
    \end{verbatim}

    \subsection{}

    TODO: Add appropriate mathematical symbol for union operation.

    The dynamic-set operation \textit{UNION} takes two disjoint sets S1 and S2
    as input, and it returns a set S = S1 U S2 consisting of all the elements
    of S1 and S2. The sets S1 and S2 are usually destroyed by the operation.
    Show how to support \textit{UNION} in O(1) time using a suitable list data
    structure.

    \subsubsection{Answer}

    We can use circular doubly linked list data structure for storing elements
    of a set. Choosing circular doubly linked list we will be able to get a
    reference of first node which is called head and a last node of a linked
    list in O(1).

    For achieving an \textit{UNION} operation in O(1) run-time, we have to
    update a next value of last node of S1 with a head node of S2 and point
    last node of S2 to a head node of S1. Because we have reference of first
    and last node, we can achieve this operation in O(1) time.

    \subsection{}

    Given a O(n)-time non recursive procedure that reverses a singly linked list
    of n elements. The procedure should use no more than constant storage
    beyond that needed for the list itself.

    \subsubsection{Answer}

    There are two ways to reverse a singly linked list. Both will take O(n) run
    time.

    Below is a first approach in which I am reversing a singly linked list
    using Stack data structure.

    \begin{verbatim}
      REVERSE(L)
        S = Stack()
        element = L.head
        while element.next != null
          PUSH(S, element)
          element = element.next
        RL = LinkedList()
        last_element = null
        while S.length != 0
          element = POP(S)
          INSERT(RL, element)
        return RL
    \end{verbatim}

    Blow is a second approach in which I am reversing a singly linked list
    operations without using any data structure.

    \begin{verbatim}
    POP(L)
      if L.head == null
        error ``Underflow``
      element = L.head
      L.head = L.head.next
      return element

    INSERT(L, element)
      if L.head == null
        L.head = item
      element.next = L.head
      L.head = element

    REVERSE(L)
      RL = SinglyList()
      while L.length != 0
        element = POP(L)
        INSERT(RL, element)
      return RL
    \end{verbatim}

    \subsection{}

    Explain how to implement doubly linked lists using only one pointer value
    x.np per item instead of the usual two (next and prev). Assume that all
    pointer values can be interpreted as k-bit integers, and define x.np to be
    x.np = x.next XOR x.prev, the k-bit ``exclusive-or`` of x.next and x.prev.
    (The value NUL is represented by 0.) Be sure to describe what information
    you need to access the head of the list. Show how to implement the
    \textit{SEARCH}, \textit{INSERT}, and \textit{DELETE} operations on such a
    list. Also show how to reverse such a list in O(1) time.

    \subsubsection{Answer}

    TODO: Learn how XOR on bit works.
