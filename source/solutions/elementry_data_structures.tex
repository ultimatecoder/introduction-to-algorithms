\chapter{Elementary Data Structures}
  \section{Stacks and Queues}
    \subsection {}

    Using Figure 10.1 as a model, illustrate the result of each operation in
    the sequence \textit{PUSH(S, 4), PUSH(S, 1), PUSH(S, 3), POP(S), PUSH(S,
    8)}, and \textit{POP(S)} on an initially empty stack \textit{S} stored in
    array S[1..6].

      \subsubsection {Answer}

      Below are various state of a Stack after performing mentioned operations.

      \textit{PUSH(S, 4)}

      \begin{verbatim}
        S = [4, null, null, null, null, null]
        s.top = 0
      \end{verbatim}

      \textit{PUSH(S, 1)}

      \begin{verbatim}
        S = [4, 1, null, null, null, null]
        S.top = 1
      \end{verbatim}

      \textit{PUSH(S, 3)}

      \begin{verbatim}
        S = [4, 1, 3, null, null, null]
        S.top = 2
      \end{verbatim}

      \textit{POP(S)}

      \begin{verbatim}
        S = [4, 1, null, null, null, null]
        S.top = 1
      \end{verbatim}

      \textit{PUSH(S, 8)}

      \begin{verbatim}
        S = [4, 1, 8, null, null, null]
        S.top = 2
      \end{verbatim}

      \textit{POP(S)}

      \begin{verbatim}
        S = [4, 1, null, null, null, null]
        S.top = 1
      \end{verbatim}

      \subsection{}

      Explain how to implement two stacks in one Array A[1..n] in such a way
      that neither stack overflows unless the total number of elements in both
      stacks together is n. The \textit{PUSH} and \textit{POP} operations
      should run in O(1) time.

        \subsubsection {Answer}

        We can implement two stacks in one Array by putting two reference
        pointers on an Array.

        Let us call S1 a stack which stores elements from a beginning to an end
        in an increment order in an Array. S1 has a pointer called ``top``
        which is being incremented at the time of adding an element. ``top`` is
        decremented when element is removed from stack.

        Let us call S2 a stack which stores elements from end to beginning in a
        decrement order on same Array. S2 has a pointer called ``end`` which is
        being decremented at the time of adding element. ``end`` is incremented
        when element is removed from an stack.

        An overflow of stack can be identified by three conditions. One is when
        pointer of S1 and S2 reaches at a same position. Second is when pointer
        of S1 reaches an end of an array. Third is when pointer of S2 reaches
        at a beginning of an array.

        We can identify an underflow of a stack by measuring that pointer of S1
        is not less than zero (0) and pointer of S2 is not greater than size of
        an array.

        Below is a pseudocode for \textit{PUSH} and \textit{POP} operations of
        both stacks. Operations for stack S2 which stores elements via pointer
        placed at an end of an Array.

        \begin{verbatim}
          STACK-EMPTY(S)
            if S.end == S.length
              return TRUE
            else
              return FALSE
        \end{verbatim}

        \begin{verbatim}
          PUSH(S, item)
            S.end = S.end - 1
            if S.end == S.top Or S.end < 0
              error ``Overflow``
            else
              S[s.end] = item
        \end{verbatim}

        \begin{verbatim}
          POP(S, item)
            if STACK-EMPTY(S)
              return ``Underflow``
            else
              S.end = S.end + 1
              return S[S.end - 1]
        \end{verbatim}

        Operations of stack S1 which stores elements from front will be same as
        defined in normal stack except \textit{PUSH} operation. Below is a code
        of \textit{PUSH} operation.

        \begin{verbatim}
          PUSH(S, item)
            S.top += 1
            if S.top == S.end or S.top == S.length
              return ``Overflow``
            else
              S[S.top] = item
        \end{verbatim}

      \subsection{}

      Using Figure 10.2 as a model, illustrate the result of each operation in
      the sequence \textit{ENQUEUE(Q, 4)}, \textit{ENQUEUE(Q, 1)},
      \textit{ENQUEUE(Q, 3)}, \textit{DEQUEUE(Q)}, \textit{ENQUEUE(Q, 8)}, and
      \textit{DEQUEUE(Q)} on an initially empty queue Q stored in array
      Q[1..6].

        \subsubsection{Answer}

          Below are state of queue after performing sequene of \textit{ENQUEUE}
          and \textit{DEQUEUE}.

          \textit{ENQUEUE(Q, 4)}
          \begin{verbatim}
            Q = [4, null, null, null, null, null]
            Q.head = 1
            Q.tail = 1
          \end{verbatim}

          \textit{ENQUEUE(Q, 1)}
          \begin{verbatim}
            Q = [4, 1, null, null, null, null]
            Q.head = 1
            Q.tail = 2
          \end{verbatim}

          \textit{ENQUEUE(Q, 3)}
          \begin{verbatim}
            Q = [4, 1, 3, null, null, null]
            Q.head = 1
            Q.tail = 3
          \end{verbatim}

          \textit{DEQUEUE(Q)}
          \begin{verbatim}
            Q = [null, 1, 3, null, null, null]
            Q.head = 2
            Q.tail = 3
          \end{verbatim}

          \textit{ENQUEUE(Q, 8)}
          \begin{verbatim}
            Q = [null, 1, 3, 8, null, null]
            Q.head = 1
            Q.tail = 4
          \end{verbatim}

          \textit{DEQUEUE(Q)}
          \begin{verbatim}
            Q = [null, null, 3, 8, null, null]
            Q.head = 2
            Q.tail = 3
          \end{verbatim}

          In above code, I am depicting an empty elements position as a
          \textit{null}.

      \subsection{}

      Rewrite \textit{ENQUEUE} and \textit{DEQUEUE} to detect underflow and
      overflow of a queue.

        \subsubsection {Answer}

        \begin{verbatim}
          ENQUEUE(Q, item)
            if Q.tail == Q.length
              Q.tail = 1
            else
              Q.tail = Q.tail + 1
            if Q.tail == Q.head:
              error ``Overflow``
            else
              Q[Q.tail] = item

          DEQUEUE(Q)
            if Q.head == Q.tail + 1
              return ``Underflow``
            else
              item = Q[Q.head]
            if Q.head == Q.length
              Q.head = 1
            else
              Q.head = Q.head + 1
            return item
        \end{verbatim}

      \subsection{}

      Whereas a stack allows insertion and deletion of elements at only one
      end, and a queue allows insertion and one end and deletion at the other
      end, a \textit{deque} (double-ended queue) allows insertion and deletion
      at both ends. Write four O(1) time procedures to insert elements into and
      delete elements from both ends of a deque implemented by an array.

        \subsubsection{Answer}
          Below are four operations to be performed on double ended queue.

          TODO: Treat this queue as a circular queue. Implement each method to
          detect underflow and overflow conditions.

          \begin{verbatim}

            FRONT-ENQUEUE(Q, intem)
              Q.head = Q.head - 1
              if Q.head == 0
                Q.head = Q.length
              Q[Q.head] = item

            REAR-ENQUEUE(Q, item)
              if Q.tail == Q.length
                Q.tail = 1
              else
                Q.tail = Q.tail + 1
              Q[Q.tail] = item

            FRONT-DEQUEUE(Q, item)
              item = Q[Q.head]
              if Q.head == Q.length
                Q.head = 1
              else
                Q.head = Q.head + 1
              return item

            REAR-DEQUEUE(Q, item)
              item = Q[Q.tail]
              Q.tail = Q.tail - 1
              if Q.tail == 0
                Q.tail = Q.length
              return item
          \end{verbatim}

      \subsection{}

        Show how to implement a queue using two stacks. Analyze the running
        time of the queue operations.

        \subsubsection{Answer}

        Below is an implementation of queue using two stacks.

        \begin{verbatim}
          ENQUEUE(Q, item)
            PUSH(S1, item)

          DEQUEUE(Q)
            while S1 is not empty
              other_item = POP(S1)
              PUSH(S2, other_item)
            item = POP(S2)
            while S2 is not empty
              other_item = POP(S2)
              PUSH(S1, other_item)
            return item
        \end{verbatim}

        In above approach, an \textit{ENQUEUE} operation is achieved in O(1)
        run-time, but a \textit{DEQUEUE} operation will take O(N).

      \subsection{}

        Show how to implement a stack using two queues. Analyze the running
        time of the stack operations.

        \subsubsection{Answer}

        Below is an implementation of stack using two queues.

        \begin{verbatim}

          PUSH(S, item)
            ENQUEUE(Q1, item)

          POP(S)
            while Q1.length != 1
              other_item = DEQUEUE(Q1)
              ENQUEUE(Q2, other_item)
            item = DEQUEUE(Q1)
            while Q2 is not empty
              other_item = DEQUEUE(Q2)
              ENQUEUE(Q1, other_item)
            return item
        \end{verbatim}

        A run-time of \textit{PUSH} operation can be achieved in O(1).
        \textit{POP} operation will take O(N) to remove an element from top.
